import os
import csv
import json
import subprocess
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed
import magic
import pandas as pd
# import sys
# sys.path.insert(0, os.path.abspath(os.path.join(os.path.curdir, '..')))
from modeling.constant import *
from modeling.helper import encode_f1, encode_f3, get_file_name
from functools import reduce


def run_command(command):
    try:
        result = subprocess.run(command, capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        return f"Error: {e}"

def parse_pdfid_output(output):
    lines = output.split("\n")
    features = {}
    for line in lines[1:]:
        if line.startswith(" PDF Header:"):
            features["PDF Header"] = line.split(":")[1].strip()
        elif line.strip():
            parts = line.rsplit(maxsplit=1)
            if len(parts) == 2:
                key, value = parts
                features[key.strip()] = int(value)
    return features

def F1(file_path, title_length):
    print(f"Processing F1 for {file_path}")
    output = run_command(["pdfid_v0_2_8/pdfid.py", file_path])
    features = parse_pdfid_output(output)
    if not features:
        return features
    features["File"] = file_path
    features["Headerlength"] = title_length
    features["Headercorrupt"] = 1 if not features.get("PDF Header", "").startswith("%PDF-1.") else 0
    features["Small content"] = 1 if features.get("obj", 0) <= 14 else 0
    features["Content corrupt"] = 1 if features.get("obj", 0) != features.get("endobj", 0) else 0
    features["Stream corrupt"] = 1 if features.get("stream", 0) != features.get("endstream", 0) else 0
    malice_content_count = sum(features.get(key, 0) for key in ["/JS", "/JavaScript", "/AA", "/Launch", "/OpenAction"])
    features["Malicecontent"] = 1 if malice_content_count >= 2 else 0
    features["Hidden File"] = 1 if "Hidden" in output else 0
    return features

def F2(file_path):
    print(f"Processing F2 for {file_path}")
    output = run_command(["pdfinfo", file_path])
    lines = output.split('\n')
    features = {"File": file_path}
    title_length = 0
    for line in lines:
        if ':' in line:
            key, value = map(str.strip, line.split(':', 1))
            features[key.replace(' ', '_')] = value
            if key == "Title":
                title_length = len(value)
    return features, title_length

def F3(file_path):
    print(f"Processing F3 for {file_path}")
    output = run_command(["pdf-parser_V0_7_8/pdf-parser.py", file_path])
    features = {
        "File": file_path,
        "/JS": output.count("/JS"),
        "/JavaScript": output.count("/JavaScript"),
        "/Size": output.count("/Size"),
        "startxref": output.count("startxref"),
        "%EOF": output.count("%EOF"),
        "/Producer": output.count("/Producer"),
        "/ProcSet": output.count("/ProcSet"),
        "/ID": output.count("/ID"),
        "/S": output.count("/S"),
        "/CreationDate": output.count("/CreationDate"),
        "obj": output.count("obj"),
        "xref": output.count("xref"),
        "<<": output.count("<<"),
        ">>": output.count(">>"),
        "/Font": output.count("/Font"),
        "/XObject": output.count("/XObject"),
        "/ModDate": output.count("/ModDate"),
        "/Info": output.count("/Info"),
        "/XML": output.count("/XML"),
        "Comment": output.count("Comment"),
        "/Widget": output.count("/Widget"),
        "Referencing": output.count("Referencing"),
        "/FontDescriptor": output.count("/FontDescriptor"),
        "/Image": output.count("/Image"),
        "/Rect": output.count("/Rect"),
        "/Length": output.count("/Length"),
        "/Action": output.count("/Action")
    }
    return features

def analyze_pdf(file_path):
    try:
        f2_features, title_length = F2(file_path)
        f1_features = F1(file_path, title_length)
        f3_features = F3(file_path)
    except Exception as e:
        print(f"Error processing {file_path}: {e}")
        f1_features = None
        f2_features = None
        f3_features = None
    return f1_features, f2_features, f3_features

def save_to_csv(data, output_csv):
    for feature_set, filename in zip(data, output_csv):
        with open(filename, mode='w', newline='', encoding='utf-8') as file:
            writer = csv.writer(file, escapechar='\\', quoting=csv.QUOTE_MINIMAL)
            headers = feature_set[0].keys()
            writer.writerow(headers)
            for row in feature_set:
                writer.writerow(row.values())

def is_pdf(file_path):
    mime = magic.Magic(mime=True)
    file_mime_type = mime.from_file(file_path)
    return file_mime_type == 'application/pdf'

def encode_f2(df: pd.DataFrame, rules: dict):
    ret = pd.DataFrame()
    for column, rule in rules.items():
        ret[column] = df[column].map(rule)
    ret['File'] = df['File'].apply(get_file_name)
    return ret

def main(pdf_file):
    pdf_files = [pdf_file]
    # pdf_files = [f for f in Path(pdf_directory).rglob('*') if is_pdf(f)]
    f1_data = []
    f2_data = []
    f3_data = []
    with ThreadPoolExecutor() as executor:
        futures = {executor.submit(analyze_pdf, str(pdf_file)): pdf_file for pdf_file in pdf_files}
        for future in as_completed(futures):
            f1_features, f2_features, f3_features = future.result()
            if f1_features and f2_features and f3_features:
                f1_data.append(f1_features)
                f2_data.append(f2_features)
                f3_data.append(f3_features)
    f1, f2, f3 = [pd.DataFrame(f) for f in [f1_data, f2_data, f3_data]]
    final_f1 = encode_f1(f1)
    f2_encoding_rules = json.load(open("./Dataset/processed/combined/f2_rules.json"))
    final_f2 = encode_f2(f2, f2_encoding_rules)
    final_f3 = encode_f3(f3)
    dfs = [final_f1, final_f2, final_f3]
    final_features = reduce(lambda left, right: pd.merge(left, right, on="File", how='inner'), dfs)
    return final_features[final_features.columns[1:]].reindex(columns=final_columns).fillna(0)
    
if __name__ == "__main__":
    pdf_directory = "./uploads"  # Replace PDF directory
    main(pdf_directory)
